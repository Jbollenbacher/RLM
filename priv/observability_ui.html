    <!doctype html>
    <html>
      <head>
        <meta charset="utf-8" />
        <title>RLM Web Console</title>
        <style>
          :root {
            --bg: #0b0d12;
            --panel: #151824;
            --text: #e9eef8;
            --muted: #9aa3b2;
            --accent: #6bdcff;
            --border: #263044;
            --danger: #ff8b8b;
            --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
          }
          body {
            margin: 0;
            background: radial-gradient(circle at 20% 20%, #1a2030 0%, #0b0d12 50%, #07080c 100%);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, sans-serif;
          }
          header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 12px;
          }
          header .dot {
            width: 8px;
            height: 8px;
            background: var(--accent);
            border-radius: 999px;
            box-shadow: 0 0 12px rgba(107, 220, 255, 0.9);
          }
          main {
            display: grid;
            grid-template-columns: minmax(320px, var(--chat-col, 48%)) 10px minmax(420px, 1fr);
            grid-template-rows: minmax(0, 1fr);
            gap: 0;
            padding: 16px;
            height: calc(100vh - 58px);
            box-sizing: border-box;
          }
          #chat-column {
            display: flex;
            min-height: 0;
            height: 100%;
            padding-right: 8px;
          }
          #main-splitter {
            width: 10px;
            cursor: col-resize;
            touch-action: none;
            position: relative;
          }
          #main-splitter::before {
            content: "";
            position: absolute;
            top: 6px;
            bottom: 6px;
            left: 3px;
            width: 4px;
            border-radius: 999px;
            background: linear-gradient(180deg, rgba(107, 220, 255, 0.15), rgba(107, 220, 255, 0.35));
            border: 1px solid rgba(107, 220, 255, 0.22);
          }
          #main-splitter:hover::before {
            background: linear-gradient(180deg, rgba(107, 220, 255, 0.35), rgba(107, 220, 255, 0.6));
          }
          #observability-column {
            min-height: 0;
            display: grid;
            grid-template-columns: minmax(0, 1fr) 10px minmax(220px, var(--obs-side-col, 300px));
            grid-template-rows: minmax(0, 1fr);
            gap: 0;
            padding-left: 8px;
          }
          #obs-context-panel {
            padding-right: 8px;
          }
          #obs-column-splitter {
            width: 10px;
            cursor: col-resize;
            touch-action: none;
            position: relative;
          }
          #obs-column-splitter::before {
            content: "";
            position: absolute;
            top: 6px;
            bottom: 6px;
            left: 3px;
            width: 4px;
            border-radius: 999px;
            background: linear-gradient(180deg, rgba(107, 220, 255, 0.15), rgba(107, 220, 255, 0.35));
            border: 1px solid rgba(107, 220, 255, 0.22);
          }
          #obs-column-splitter:hover::before {
            background: linear-gradient(180deg, rgba(107, 220, 255, 0.35), rgba(107, 220, 255, 0.6));
          }
          #obs-side-stack {
            min-height: 0;
            display: grid;
            grid-template-rows: minmax(140px, var(--obs-agents-row, 50%)) 10px minmax(140px, 1fr);
            gap: 0;
            padding-left: 8px;
          }
          #obs-stack-splitter {
            height: 10px;
            cursor: row-resize;
            touch-action: none;
            position: relative;
          }
          #obs-stack-splitter::before {
            content: "";
            position: absolute;
            left: 6px;
            right: 6px;
            top: 3px;
            height: 4px;
            border-radius: 999px;
            background: linear-gradient(90deg, rgba(107, 220, 255, 0.15), rgba(107, 220, 255, 0.35));
            border: 1px solid rgba(107, 220, 255, 0.22);
          }
          #obs-stack-splitter:hover::before {
            background: linear-gradient(90deg, rgba(107, 220, 255, 0.35), rgba(107, 220, 255, 0.6));
          }
          .panel {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            min-height: 0;
          }
          .panel h2 {
            margin: 0 0 8px 0;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: var(--muted);
          }
          .panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
          }
          .context-controls {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
          }
          .toggle {
            font-size: 12px;
            color: var(--muted);
            display: inline-flex;
            align-items: center;
            gap: 6px;
            user-select: none;
          }
          .toggle input {
            accent-color: var(--accent);
          }
          #copy-context {
            padding: 4px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: rgba(107, 220, 255, 0.12);
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
          }
          #export-logs {
            padding: 4px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: rgba(146, 255, 184, 0.12);
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
          }
          #preview-logs {
            padding: 4px 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: rgba(255, 214, 130, 0.12);
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
          }
          #copy-context:hover {
            background: rgba(107, 220, 255, 0.2);
          }
          #export-logs:hover {
            background: rgba(146, 255, 184, 0.2);
          }
          #preview-logs:hover {
            background: rgba(255, 214, 130, 0.2);
          }
          #context-copy-status {
            min-width: 70px;
            font-size: 12px;
            color: var(--muted);
          }
          #context-copy-status.error {
            color: var(--danger);
          }
          #context-export-status {
            min-width: 70px;
            font-size: 12px;
            color: var(--muted);
          }
          #context-export-status.error {
            color: var(--danger);
          }
          #context-preview-status {
            min-width: 70px;
            font-size: 12px;
            color: var(--muted);
          }
          #context-preview-status.error {
            color: var(--danger);
          }
          #agents {
            overflow: auto;
            font-size: 13px;
          }
          .agent {
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid transparent;
            display: flex;
            align-items: center;
            gap: 6px;
          }
          .agent.active {
            border-color: var(--accent);
            background: rgba(107, 220, 255, 0.08);
          }
          .agent-toggle {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 0;
            border-radius: 4px;
            background: transparent;
            color: var(--muted);
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
          }
          .agent-toggle:hover {
            background: rgba(107, 220, 255, 0.12);
            color: var(--text);
          }
          .agent-toggle.placeholder {
            cursor: default;
            color: rgba(154, 163, 178, 0.4);
          }
          .agent-label {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
          }
          #context {
            flex: 1;
            background: #0b0f18;
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 12px;
            font-family: var(--mono);
            font-size: 12px;
            white-space: pre-wrap;
            overflow: auto;
          }
          #full-logs-preview {
            margin-top: 10px;
            flex: 0 0 260px;
            background: #0b0f18;
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 12px;
            font-family: var(--mono);
            font-size: 11px;
            white-space: pre;
            overflow: auto;
          }
          #events {
            flex: 1;
            overflow: auto;
            font-family: var(--mono);
            font-size: 11px;
          }
          .event {
            padding: 6px 0;
            border-bottom: 1px dashed rgba(38, 48, 68, 0.6);
          }
          .chat-panel {
            min-height: 0;
            flex: 1;
          }
          #chat-log {
            flex: 1;
            min-height: 0;
            background: #0b0f18;
            border-radius: 8px;
            border: 1px solid var(--border);
            padding: 12px;
            overflow: auto;
          }
          .chat-msg {
            margin-bottom: 10px;
            white-space: pre-wrap;
            line-height: 1.35;
          }
          .chat-msg .role {
            font-size: 11px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--muted);
            margin-bottom: 3px;
          }
          .chat-msg.user .role {
            color: var(--accent);
          }
          .chat-msg.assistant .role {
            color: #92ffb8;
          }
          #chat-form {
            margin-top: 10px;
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 10px;
          }
          #chat-input {
            resize: none;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #0b0f18;
            color: var(--text);
            font-family: var(--mono);
            font-size: 12px;
          }
          #chat-send {
            padding: 0 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: rgba(107, 220, 255, 0.12);
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
          }
          #chat-send:disabled {
            opacity: 0.6;
            cursor: not-allowed;
          }
          #chat-stop {
            padding: 0 14px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: rgba(255, 139, 139, 0.12);
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
          }
          #chat-stop:disabled {
            opacity: 0.6;
            cursor: not-allowed;
          }
          #chat-status {
            font-size: 12px;
            color: var(--muted);
          }
          #chat-status.error {
            color: var(--danger);
          }
          .muted {
            color: var(--muted);
          }
          body.resizing-col,
          body.resizing-col * {
            cursor: col-resize !important;
            user-select: none !important;
          }
          body.resizing-row,
          body.resizing-row * {
            cursor: row-resize !important;
            user-select: none !important;
          }
          @media (max-width: 980px) {
            main {
              height: auto;
              grid-template-columns: 1fr;
              grid-template-rows: auto auto;
              gap: 16px;
            }
            #chat-column {
              min-height: 360px;
              padding-right: 0;
            }
            #main-splitter {
              display: none;
            }
            #observability-column {
              grid-template-columns: 1fr;
              grid-template-rows: auto auto;
              padding-left: 0;
            }
            #obs-context-panel {
              padding-right: 0;
            }
            #obs-column-splitter {
              display: none;
            }
            #obs-side-stack {
              grid-template-rows: auto auto;
              padding-left: 0;
            }
            #obs-stack-splitter {
              display: none;
            }
            #agents,
            #events {
              max-height: 240px;
            }
          }
        </style>
      </head>
      <body>
        <header>
          <div class="dot"></div>
          <strong>RLM Web Console</strong>
        </header>
        <main>
          <section id="chat-column">
            <section class="panel chat-panel">
              <div class="panel-header">
                <h2>Chat</h2>
                <span id="chat-status">Ready</span>
              </div>
              <div id="chat-log" class="muted">Chat loading...</div>
              <form id="chat-form">
                <textarea id="chat-input" rows="3" placeholder="Ask something..."></textarea>
                <button id="chat-send" type="submit">Send</button>
                <button id="chat-stop" type="button" disabled>Stop</button>
              </form>
            </section>
          </section>
          <div id="main-splitter" role="separator" aria-orientation="vertical" aria-label="Resize panels"></div>
          <section id="observability-column">
            <section id="obs-context-panel" class="panel">
              <div class="panel-header">
                <h2>Context Window</h2>
                <div class="context-controls">
                  <label class="toggle">
                    <input type="checkbox" id="toggle-system" />
                    Show system prompt
                  </label>
                  <label class="toggle">
                    <input type="checkbox" id="toggle-debug-logs" />
                    Debug logs
                  </label>
                  <button id="copy-context" type="button">Copy Context</button>
                  <span id="context-copy-status" aria-live="polite"></span>
                  <button id="preview-logs" type="button">Show Full Agent Logs</button>
                  <span id="context-preview-status" aria-live="polite"></span>
                  <button id="export-logs" type="button">Export Full Agent Logs</button>
                  <span id="context-export-status" aria-live="polite"></span>
                </div>
              </div>
              <div id="context" class="muted">Select an agent to view context.</div>
              <pre id="full-logs-preview" class="muted" hidden>Click "Show Full Agent Logs" to preview export JSON.</pre>
            </section>
            <div id="obs-column-splitter" role="separator" aria-orientation="vertical" aria-label="Resize observability panels"></div>
            <section id="obs-side-stack">
              <section class="panel">
                <h2>Agents</h2>
                <div id="agents"></div>
              </section>
              <div id="obs-stack-splitter" role="separator" aria-orientation="horizontal" aria-label="Resize agents and events"></div>
              <section class="panel">
                <h2>Event Feed</h2>
                <div id="events"></div>
              </section>
            </section>
          </section>
        </main>
        <script>
          const state = {
            agents: [],
            selectedAgent: null,
            lastEventTs: 0,
            lastEventId: 0,
            lastSnapshotId: 0,
            showSystem: false,
            debugLogs: false,
            fullLogsVisible: false,
            expandedAgents: new Set(),
            chatSessionId: null,
            chatLastMessageId: 0,
            chatBusy: false
          };

          function isMobileLayout() {
            return window.matchMedia("(max-width: 980px)").matches;
          }

          function setupMainSplitter() {
            const main = document.querySelector("main");
            const splitter = document.getElementById("main-splitter");
            if (!main || !splitter) return;

            const MIN_CHAT = 320;
            const MIN_OBSERVABILITY = 420;
            const SPLITTER_WIDTH = 10;
            let dragging = false;
            let activePointerId = null;

            function clampChatWidth(nextWidth) {
              const rect = main.getBoundingClientRect();
              const maxChat = Math.max(MIN_CHAT, rect.width - SPLITTER_WIDTH - MIN_OBSERVABILITY);
              return Math.min(maxChat, Math.max(MIN_CHAT, nextWidth));
            }

            function applyChatWidth(nextWidth) {
              const clamped = clampChatWidth(nextWidth);
              main.style.setProperty("--chat-col", `${clamped}px`);
            }

            function stopDrag(event) {
              if (!dragging) return;
              dragging = false;
              document.body.classList.remove("resizing-col");

              if (
                event &&
                  activePointerId != null &&
                  splitter.hasPointerCapture &&
                  splitter.hasPointerCapture(activePointerId)
              ) {
                splitter.releasePointerCapture(activePointerId);
              }

              activePointerId = null;
            }

            splitter.addEventListener("pointerdown", event => {
              if (isMobileLayout()) return;
              dragging = true;
              activePointerId = event.pointerId;
              document.body.classList.add("resizing-col");
              splitter.setPointerCapture(event.pointerId);
              const rect = main.getBoundingClientRect();
              applyChatWidth(event.clientX - rect.left);
              event.preventDefault();
            });

            splitter.addEventListener("pointermove", event => {
              if (!dragging || event.pointerId !== activePointerId) return;
              const rect = main.getBoundingClientRect();
              applyChatWidth(event.clientX - rect.left);
            });

            splitter.addEventListener("pointerup", stopDrag);
            splitter.addEventListener("pointercancel", stopDrag);
            window.addEventListener("pointerup", stopDrag);

            window.addEventListener("resize", () => {
              if (isMobileLayout()) {
                stopDrag();
                main.style.removeProperty("--chat-col");
                return;
              }

              const current = Number.parseFloat(getComputedStyle(main).getPropertyValue("--chat-col"));
              if (Number.isFinite(current)) {
                applyChatWidth(current);
              }
            });
          }

          function setupObsColumnSplitter() {
            const container = document.getElementById("observability-column");
            const splitter = document.getElementById("obs-column-splitter");
            if (!container || !splitter) return;

            const MIN_CONTEXT = 320;
            const MIN_SIDE = 220;
            const SPLITTER_WIDTH = 10;
            let dragging = false;
            let activePointerId = null;

            function applyFromPointer(clientX) {
              const rect = container.getBoundingClientRect();
              const desiredContext = clientX - rect.left;
              const maxContext = Math.max(MIN_CONTEXT, rect.width - SPLITTER_WIDTH - MIN_SIDE);
              const contextWidth = Math.min(maxContext, Math.max(MIN_CONTEXT, desiredContext));
              const sideWidth = rect.width - SPLITTER_WIDTH - contextWidth;
              container.style.setProperty("--obs-side-col", `${sideWidth}px`);
            }

            function clampSideWidth(sideWidth) {
              const rect = container.getBoundingClientRect();
              const maxSide = Math.max(MIN_SIDE, rect.width - SPLITTER_WIDTH - MIN_CONTEXT);
              return Math.min(maxSide, Math.max(MIN_SIDE, sideWidth));
            }

            function stopDrag(event) {
              if (!dragging) return;
              dragging = false;
              document.body.classList.remove("resizing-col");

              if (
                event &&
                  activePointerId != null &&
                  splitter.hasPointerCapture &&
                  splitter.hasPointerCapture(activePointerId)
              ) {
                splitter.releasePointerCapture(activePointerId);
              }

              activePointerId = null;
            }

            splitter.addEventListener("pointerdown", event => {
              if (isMobileLayout()) return;
              dragging = true;
              activePointerId = event.pointerId;
              document.body.classList.add("resizing-col");
              splitter.setPointerCapture(event.pointerId);
              applyFromPointer(event.clientX);
              event.preventDefault();
            });

            splitter.addEventListener("pointermove", event => {
              if (!dragging || event.pointerId !== activePointerId) return;
              applyFromPointer(event.clientX);
            });

            splitter.addEventListener("pointerup", stopDrag);
            splitter.addEventListener("pointercancel", stopDrag);
            window.addEventListener("pointerup", stopDrag);

            window.addEventListener("resize", () => {
              if (isMobileLayout()) {
                stopDrag();
                container.style.removeProperty("--obs-side-col");
                return;
              }

              const current = Number.parseFloat(
                getComputedStyle(container).getPropertyValue("--obs-side-col")
              );

              if (Number.isFinite(current)) {
                container.style.setProperty("--obs-side-col", `${clampSideWidth(current)}px`);
              }
            });
          }

          function setupObsStackSplitter() {
            const container = document.getElementById("obs-side-stack");
            const splitter = document.getElementById("obs-stack-splitter");
            if (!container || !splitter) return;

            const MIN_AGENTS = 140;
            const MIN_EVENTS = 140;
            const SPLITTER_HEIGHT = 10;
            let dragging = false;
            let activePointerId = null;

            function applyFromPointer(clientY) {
              const rect = container.getBoundingClientRect();
              const desiredAgents = clientY - rect.top;
              const maxAgents = Math.max(MIN_AGENTS, rect.height - SPLITTER_HEIGHT - MIN_EVENTS);
              const agentsHeight = Math.min(maxAgents, Math.max(MIN_AGENTS, desiredAgents));
              container.style.setProperty("--obs-agents-row", `${agentsHeight}px`);
            }

            function clampAgentsHeight(height) {
              const rect = container.getBoundingClientRect();
              const maxAgents = Math.max(MIN_AGENTS, rect.height - SPLITTER_HEIGHT - MIN_EVENTS);
              return Math.min(maxAgents, Math.max(MIN_AGENTS, height));
            }

            function stopDrag(event) {
              if (!dragging) return;
              dragging = false;
              document.body.classList.remove("resizing-row");

              if (
                event &&
                  activePointerId != null &&
                  splitter.hasPointerCapture &&
                  splitter.hasPointerCapture(activePointerId)
              ) {
                splitter.releasePointerCapture(activePointerId);
              }

              activePointerId = null;
            }

            splitter.addEventListener("pointerdown", event => {
              if (isMobileLayout()) return;
              dragging = true;
              activePointerId = event.pointerId;
              document.body.classList.add("resizing-row");
              splitter.setPointerCapture(event.pointerId);
              applyFromPointer(event.clientY);
              event.preventDefault();
            });

            splitter.addEventListener("pointermove", event => {
              if (!dragging || event.pointerId !== activePointerId) return;
              applyFromPointer(event.clientY);
            });

            splitter.addEventListener("pointerup", stopDrag);
            splitter.addEventListener("pointercancel", stopDrag);
            window.addEventListener("pointerup", stopDrag);

            window.addEventListener("resize", () => {
              if (isMobileLayout()) {
                stopDrag();
                container.style.removeProperty("--obs-agents-row");
                return;
              }

              const current = Number.parseFloat(
                getComputedStyle(container).getPropertyValue("--obs-agents-row")
              );

              if (Number.isFinite(current)) {
                container.style.setProperty("--obs-agents-row", `${clampAgentsHeight(current)}px`);
              }
            });
          }

          async function fetchJSON(url, opts = {}) {
            const res = await fetch(url, opts);
            const data = await res.json().catch(() => ({}));

            if (!res.ok) {
              const message = data.error || `Request failed (${res.status})`;
              throw new Error(message);
            }

            return data;
          }

          function setChatStatus(message, isError = false) {
            const el = document.getElementById("chat-status");
            el.textContent = message;
            el.className = isError ? "error" : "";
          }

          function buildAgentTree(agents) {
            const nodesById = new Map();
            const roots = [];

            agents.forEach(agent => {
              nodesById.set(agent.id, { ...agent, children: [] });
            });

            agents.forEach(agent => {
              const node = nodesById.get(agent.id);
              if (agent.parent_id && nodesById.has(agent.parent_id)) {
                nodesById.get(agent.parent_id).children.push(node);
              } else {
                roots.push(node);
              }
            });

            return roots;
          }

          function displayAgentId(node, treePath) {
            return `${treePath} ${node.id}`;
          }

          function ensureExpandedForNewAgents(nextAgents) {
            const existing = new Set(state.agents.map(agent => agent.id));

            nextAgents.forEach(agent => {
              if (!existing.has(agent.id)) {
                if (agent.parent_id) {
                  state.expandedAgents.add(agent.parent_id);
                } else {
                  state.expandedAgents.add(agent.id);
                }
              }
            });
          }

          function renderAgentNode(node, depth, treePath) {
            const container = document.getElementById("agents");
            const div = document.createElement("div");
            div.className = "agent" + (state.selectedAgent === node.id ? " active" : "");
            div.style.paddingLeft = `${8 + depth * 14}px`;

            const hasChildren = node.children && node.children.length > 0;
            const isExpanded = state.expandedAgents.has(node.id);
            const toggle = document.createElement("button");
            toggle.className = "agent-toggle" + (hasChildren ? "" : " placeholder");
            toggle.textContent = hasChildren ? (isExpanded ? "▾" : "▸") : "•";
            toggle.disabled = !hasChildren;
            toggle.onclick = event => {
              event.stopPropagation();
              if (!hasChildren) return;
              if (isExpanded) {
                state.expandedAgents.delete(node.id);
              } else {
                state.expandedAgents.add(node.id);
              }
              renderAgents();
            };

            const label = document.createElement("span");
            label.className = "agent-label";
            label.textContent = `${displayAgentId(node, treePath)} (${node.status || "unknown"})`;

            div.appendChild(toggle);
            div.appendChild(label);
            div.onclick = () => {
              exitFullLogsPreview();
              state.selectedAgent = node.id;
              state.lastEventTs = 0;
              state.lastEventId = 0;
              state.lastSnapshotId = 0;
              document.getElementById("events").innerHTML = "";
              loadContext(true);
              renderAgents();
            };

            container.appendChild(div);

            if (hasChildren && isExpanded) {
              node.children.forEach((child, index) => {
                renderAgentNode(child, depth + 1, `${treePath}.${index + 1}`);
              });
            }
          }

          function renderAgents() {
            const container = document.getElementById("agents");
            container.innerHTML = "";
            const roots = buildAgentTree(state.agents);
            roots.forEach((root, index) => renderAgentNode(root, 0, String(index + 1)));
          }

          async function loadAgents() {
            const data = await fetchJSON("/api/agents");
            const nextAgents = data.agents || [];
            ensureExpandedForNewAgents(nextAgents);
            state.agents = nextAgents;

            if (!state.selectedAgent && state.chatSessionId) {
              state.selectedAgent = state.chatSessionId;
              state.expandedAgents.add(state.chatSessionId);
            } else if (!state.selectedAgent && state.agents.length > 0) {
              state.selectedAgent = state.agents[state.agents.length - 1].id;
              state.expandedAgents.add(state.selectedAgent);
            }

            renderAgents();
          }

          async function loadContext(forceScroll) {
            if (!state.selectedAgent) return;
            const includeSystem = state.showSystem ? "1" : "0";
            const data = await fetchJSON(
              `/api/agents/${state.selectedAgent}/context?include_system=${includeSystem}`
            );
            const snapshot = data.snapshot;
            const contextEl = document.getElementById("context");
            if (!snapshot) {
              contextEl.textContent = "No context yet.";
              return;
            }
            if (snapshot.id && snapshot.id === state.lastSnapshotId) {
              return;
            }
            const nearBottom = contextEl.scrollTop + contextEl.clientHeight + 40 >= contextEl.scrollHeight;
            contextEl.textContent = snapshot.transcript || snapshot.preview || "";
            state.lastSnapshotId = snapshot.id || state.lastSnapshotId;
            if (forceScroll || nearBottom) {
              contextEl.scrollTop = contextEl.scrollHeight;
            }
          }

          async function pollEvents() {
            if (!state.selectedAgent) return;
            const params = new URLSearchParams({
              since: String(state.lastEventTs),
              since_id: String(state.lastEventId),
              agent_id: state.selectedAgent,
              debug: state.debugLogs ? "1" : "0"
            });
            const data = await fetchJSON(`/api/events?${params.toString()}`);
            const events = data.events || [];
            const eventsEl = document.getElementById("events");
            const nearBottom = eventsEl.scrollTop + eventsEl.clientHeight + 40 >= eventsEl.scrollHeight;
            events.forEach(evt => {
              const line = document.createElement("div");
              line.className = "event";
              const detail = evt.payload && evt.payload.duration_ms ? ` (${evt.payload.duration_ms}ms)` : "";
              line.textContent = `[${new Date(evt.ts).toLocaleTimeString()}] ${evt.type}${detail}`;
              eventsEl.appendChild(line);
            });
            if (events.length > 0) {
              const last = events[events.length - 1];
              state.lastEventTs = last.ts || state.lastEventTs;
              state.lastEventId = last.id || state.lastEventId;
              if (nearBottom) {
                eventsEl.scrollTop = eventsEl.scrollHeight;
              }
            }
          }

          function renderChat(messages, forceScroll) {
            const log = document.getElementById("chat-log");
            const nearBottom = log.scrollTop + log.clientHeight + 40 >= log.scrollHeight;
            log.classList.remove("muted");
            log.innerHTML = "";

            if (messages.length === 0) {
              log.textContent = "No messages yet. Start chatting below.";
              log.classList.add("muted");
              return;
            }

            messages.forEach(msg => {
              const block = document.createElement("div");
              block.className = `chat-msg ${msg.role || "assistant"}`;

              const role = document.createElement("div");
              role.className = "role";
              role.textContent = msg.role || "assistant";

              const content = document.createElement("div");
              content.textContent = msg.content || "";

              block.appendChild(role);
              block.appendChild(content);
              log.appendChild(block);
            });

            if (forceScroll || nearBottom) {
              log.scrollTop = log.scrollHeight;
            }
          }

          async function loadChat(forceScroll) {
            try {
              const data = await fetchJSON("/api/chat");
              state.chatSessionId = data.session_id || state.chatSessionId;

              if (!state.selectedAgent && state.chatSessionId) {
                state.selectedAgent = state.chatSessionId;
                state.expandedAgents.add(state.chatSessionId);
              }

              const messages = data.messages || [];
              const last = messages[messages.length - 1];
              const lastId = last ? last.id : 0;

              if (forceScroll || lastId !== state.chatLastMessageId) {
                renderChat(messages, forceScroll);
              }

              state.chatLastMessageId = lastId;
              setChatBusy(Boolean(data.busy));
            } catch (error) {
              setChatStatus(error.message, true);
            }
          }

          function setChatBusy(busy) {
            state.chatBusy = busy;
            const input = document.getElementById("chat-input");
            const sendButton = document.getElementById("chat-send");
            const stopButton = document.getElementById("chat-stop");
            input.disabled = busy;
            sendButton.disabled = busy;
            stopButton.disabled = !busy;
            setChatStatus(busy ? "Running..." : "Ready");
          }

          async function sendChatMessage(message) {
            await fetchJSON("/api/chat", {
              method: "POST",
              headers: { "content-type": "application/json" },
              body: JSON.stringify({ message })
            });
          }

          async function stopChatMessage() {
            await fetchJSON("/api/chat/stop", {
              method: "POST",
              headers: { "content-type": "application/json" }
            });
          }

          async function loop() {
            await loadAgents();
            await loadContext(false);
            await pollEvents();
            await loadChat(false);
            setTimeout(loop, 1000);
          }

          const statusTimers = {};

          function setTransientStatus(elementId, message, isError = false) {
            const el = document.getElementById(elementId);
            if (!el) return;

            el.textContent = message;
            el.className = isError ? "error" : "";

            if (statusTimers[elementId]) {
              clearTimeout(statusTimers[elementId]);
            }

            statusTimers[elementId] = setTimeout(() => {
              el.textContent = "";
              el.className = "";
              statusTimers[elementId] = null;
            }, 1500);
          }

          async function copyContextToClipboard() {
            const contextEl = document.getElementById("context");
            const text = (contextEl && contextEl.textContent ? contextEl.textContent : "").trim();

            if (!text || text === "Select an agent to view context." || text === "No context yet.") {
              setTransientStatus("context-copy-status", "Nothing to copy", true);
              return;
            }

            try {
              await navigator.clipboard.writeText(text);
              setTransientStatus("context-copy-status", "Copied");
            } catch (_error) {
              setTransientStatus("context-copy-status", "Copy failed", true);
            }
          }

          function exportFilenameFromHeader(headerValue) {
            if (!headerValue) return null;
            const match = headerValue.match(/filename=\"([^\"]+)\"/i);
            return match ? match[1] : null;
          }

          async function downloadFullLogs() {
            const includeSystem = state.showSystem ? "1" : "0";
            const debug = state.debugLogs ? "1" : "0";

            try {
              const response = await fetch(
                `/api/export/full_logs?include_system=${includeSystem}&debug=${debug}`
              );

              if (!response.ok) {
                throw new Error(`Export failed (${response.status})`);
              }

              const blob = await response.blob();
              const header = response.headers.get("content-disposition");
              const filename =
                exportFilenameFromHeader(header) ||
                `rlm_agent_logs_${new Date().toISOString().replace(/[:]/g, "-")}.json`;

              const url = URL.createObjectURL(blob);
              const link = document.createElement("a");
              link.href = url;
              link.download = filename;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              URL.revokeObjectURL(url);

              setTransientStatus("context-export-status", "Downloaded");
            } catch (error) {
              setTransientStatus("context-export-status", error.message || "Export failed", true);
            }
          }

          function setPreviewButtonLabel() {
            const previewLogsButton = document.getElementById("preview-logs");
            if (!previewLogsButton) return;
            previewLogsButton.textContent = state.fullLogsVisible ? "Refresh Logs" : "Show Full Agent Logs";
          }

          function setFullLogsPreviewVisible(visible) {
            const contextEl = document.getElementById("context");
            const previewEl = document.getElementById("full-logs-preview");

            state.fullLogsVisible = visible;

            if (contextEl) {
              contextEl.hidden = visible;
            }

            if (previewEl) {
              previewEl.hidden = !visible;
            }

            setPreviewButtonLabel();
          }

          function exitFullLogsPreview() {
            if (!state.fullLogsVisible) return;
            setFullLogsPreviewVisible(false);
          }

          async function loadFullLogsPreview() {
            const includeSystem = state.showSystem ? "1" : "0";
            const debug = state.debugLogs ? "1" : "0";
            const previewEl = document.getElementById("full-logs-preview");

            if (!previewEl) return;

            try {
              const response = await fetch(
                `/api/export/full_logs?include_system=${includeSystem}&debug=${debug}`
              );

              if (!response.ok) {
                throw new Error(`Preview failed (${response.status})`);
              }

              const text = await response.text();
              previewEl.textContent = text;
              previewEl.classList.remove("muted");
              setFullLogsPreviewVisible(true);
              setTransientStatus("context-preview-status", "Loaded");
            } catch (error) {
              setTransientStatus("context-preview-status", error.message || "Preview failed", true);
            }
          }

          const systemToggle = document.getElementById("toggle-system");
          if (systemToggle) {
            systemToggle.addEventListener("change", () => {
              state.showSystem = systemToggle.checked;
              state.lastSnapshotId = 0;
              loadContext(true);
            });
          }

          const debugLogsToggle = document.getElementById("toggle-debug-logs");
          if (debugLogsToggle) {
            debugLogsToggle.addEventListener("change", () => {
              state.debugLogs = debugLogsToggle.checked;
              state.lastEventTs = 0;
              state.lastEventId = 0;
              const eventsEl = document.getElementById("events");
              if (eventsEl) {
                eventsEl.innerHTML = "";
              }
              pollEvents();
            });
          }

          const copyContextButton = document.getElementById("copy-context");
          if (copyContextButton) {
            copyContextButton.addEventListener("click", () => {
              copyContextToClipboard();
            });
          }

          const previewLogsButton = document.getElementById("preview-logs");
          if (previewLogsButton) {
            setPreviewButtonLabel();
            previewLogsButton.addEventListener("click", () => {
              loadFullLogsPreview();
            });
          }

          const exportLogsButton = document.getElementById("export-logs");
          if (exportLogsButton) {
            exportLogsButton.addEventListener("click", () => {
              downloadFullLogs();
            });
          }

          const chatForm = document.getElementById("chat-form");
          if (chatForm) {
            chatForm.addEventListener("submit", async event => {
              event.preventDefault();

              if (state.chatBusy) return;

              const input = document.getElementById("chat-input");
              const message = input.value.trim();
              if (!message) return;

              setChatBusy(true);

              try {
                await sendChatMessage(message);
                input.value = "";
                await loadChat(true);
                await loadAgents();
                await loadContext(true);
                await pollEvents();
              } catch (error) {
                setChatStatus(error.message, true);
                setChatBusy(false);
              }
            });
          }

          const chatInput = document.getElementById("chat-input");
          if (chatInput && chatForm) {
            chatInput.addEventListener("keydown", event => {
              if (event.key === "Enter" && !event.shiftKey && !event.isComposing) {
                event.preventDefault();
                chatForm.requestSubmit();
              }
            });
          }

          const stopButton = document.getElementById("chat-stop");
          if (stopButton) {
            stopButton.addEventListener("click", async () => {
              if (!state.chatBusy) return;

              try {
                await stopChatMessage();
                await loadChat(true);
                await loadContext(true);
                await pollEvents();
              } catch (error) {
                setChatStatus(error.message, true);
              }
            });
          }

          setupMainSplitter();
          setupObsColumnSplitter();
          setupObsStackSplitter();

          Promise.all([loadChat(true), loadAgents()])
            .then(() => {
              loadContext(true);
              loop();
            })
            .catch(error => {
              setChatStatus(error.message, true);
            });
        </script>
      </body>
    </html>
